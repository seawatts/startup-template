/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: do not edit it. Instead, edit the BAML
// files and re-generate this code.
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code
'use client'

import type { BamlErrors } from '@boundaryml/baml/errors';
import { toBamlError } from '@boundaryml/baml/errors';
import { useCallback, useMemo, useReducer, useTransition } from 'react';
import * as Actions from './server';
import * as StreamingActions from './server_streaming';
import type { StreamingServerTypes } from './server_streaming_types';

/**
 * Type representing a BAML stream response.
 *
 * @template PartialType The type of the partial response.
 * @template FinalType The type of the final response.
 */
type BamlStreamResponse<PartialType, FinalType> = {
  partial?: PartialType;
  final?: FinalType;
  error?: BamlErrors;
};

/**
 * A server action that returns either a ReadableStream of Uint8Array or a final output.
 */
export type ServerAction<Input = any, Output = any> = (
  ...args: Input extends any[] ? Input : [Input]
) => Promise<Output> | ReadableStream<Uint8Array>;

/**
 * Type representing all function names except 'stream' and 'stream_types'
 */
export type FunctionNames = keyof typeof Actions;

/**
 * Helper type to derive the partial return type for an action.
 */
type StreamDataType<FunctionName extends FunctionNames> =
  StreamingServerTypes[FunctionName];

/**
 * Helper type to derive the final return type for an action.
 */
type FinalDataType<FunctionName extends FunctionNames> =
  (typeof Actions)[FunctionName] extends (...args: any) => any
    ? Awaited<ReturnType<(typeof Actions)[FunctionName]>>
    : never;

/**
 * Configuration options for BAML React hooks.
 */
export type HookInput<
  FunctionName extends FunctionNames = FunctionNames,
  Options extends { stream?: boolean } = { stream?: true },
> = {
  stream?: Options['stream'];
  onStreamData?: Options['stream'] extends false
    ? never
    : (response?: StreamDataType<FunctionName>) => void;
  onFinalData?: (response?: FinalDataType<FunctionName>) => void;
  onData?: (
    response?: Options['stream'] extends false
      ? FinalDataType<FunctionName>
      : FinalDataType<FunctionName> | StreamDataType<FunctionName>,
  ) => void;
  onError?: (error: BamlErrors) => void;
};

export type NonStreamingHookStatus = 'idle' | 'pending' | 'success' | 'error';
export type StreamingHookStatus = NonStreamingHookStatus | 'streaming';

export type HookStatus<
  Options extends { stream?: boolean } = { stream?: true },
> = Options['stream'] extends false
  ? NonStreamingHookStatus
  : StreamingHookStatus;

/**
 * Return type for BAML React hooks.
 */
export type HookOutput<
  FunctionName extends FunctionNames = FunctionNames,
  Options extends { stream?: boolean } = { stream?: true },
> = {
  data?: Options['stream'] extends false
    ? FinalDataType<FunctionName>
    : FinalDataType<FunctionName> | StreamDataType<FunctionName>;
  finalData?: FinalDataType<FunctionName>;
  streamData?: Options['stream'] extends false
    ? never
    : StreamDataType<FunctionName>;
  isLoading: boolean;
  isPending: boolean;
  isStreaming: Options['stream'] extends false ? never : boolean;
  isSuccess: boolean;
  isError: boolean;
  error?: BamlErrors;
  status: HookStatus<Options>;
  mutate: (
    ...args: Parameters<(typeof Actions)[FunctionName]>
  ) => Options['stream'] extends false
    ? Promise<FinalDataType<FunctionName>>
    : Promise<ReadableStream<Uint8Array>>;
  reset: () => void;
};

export type HookData<
  FunctionName extends FunctionNames,
  Options extends { stream?: boolean } = { stream?: true },
> = NonNullable<HookOutput<FunctionName, Options>['data']>;

/**
 * Type guard to check if the hook props are configured for streaming mode.
 *
 * @template FunctionName - The name of the BAML function.
 * @param props - The hook props.
 * @returns {boolean} True if the props indicate streaming mode.
 */
function isStreamingProps<FunctionName extends FunctionNames>(
  props: HookInput<FunctionName, { stream?: boolean }>,
): props is HookInput<FunctionName, { stream?: true }> {
  return props.stream !== false;
}

interface HookState<TPartial, TFinal> {
  isSuccess: boolean;
  isStreaming: boolean;
  error?: BamlErrors;
  finalData?: TFinal;
  streamData?: TPartial;
}

type HookStateAction<TPartial, TFinal> =
  | { type: 'START_REQUEST' }
  | { type: 'SET_ERROR'; payload: BamlErrors }
  | { type: 'SET_PARTIAL'; payload: TPartial }
  | { type: 'SET_FINAL'; payload: TFinal }
  | { type: 'RESET' };

/**
 * Reducer function to manage the hook state transitions.
 *
 * @template TPartial - The type of the partial (streaming) data.
 * @template TFinal - The type of the final (non‑streaming) data.
 * @param state - The current hook state.
 * @param action - The action to apply.
 * @returns The updated state.
 */
function hookReducer<TPartial, TFinal>(
  state: HookState<TPartial, TFinal>,
  action: HookStateAction<TPartial, TFinal>,
): HookState<TPartial, TFinal> {
  switch (action.type) {
    case 'START_REQUEST':
      return {
        ...state,
        isSuccess: false,
        error: undefined,
        isStreaming: false,
        finalData: undefined,
        streamData: undefined,
      };
    case 'SET_ERROR':
      return {
        ...state,
        isSuccess: false,
        isStreaming: false,
        error: action.payload,
      };
    case 'SET_PARTIAL':
      return {
        ...state,
        isStreaming: true,
        streamData: action.payload,
      };
    case 'SET_FINAL':
      return {
        ...state,
        isSuccess: true,
        isStreaming: false,
        finalData: action.payload,
      };
    case 'RESET':
      return {
        isSuccess: false,
        isStreaming: false,
        error: undefined,
        finalData: undefined,
        streamData: undefined,
      };
    default:
      return state;
  }
}

/**
 * Base hook for executing BAML server actions, supporting both streaming and non‑streaming modes.
 *
 * This hook provides a unified interface for handling loading states, partial updates, errors,
 * and final responses. It is designed to be used directly with any BAML server action.
 *
 * Features:
 * - **Streaming Support:** Real‑time partial updates via `streamData`, progress indicators, and incremental UI updates.
 * - **State Management:** Manages loading state (`isLoading`), success/error flags, and final/partial results.
 * - **Error Handling:** Supports type‑safe error handling for BamlValidationError, BamlClientFinishReasonError, and standard errors.
 *
 * @param Action - The server action to invoke.
 * @param props - Configuration props for the hook.
 * @returns An object with the current state and a `mutate` function to trigger the action.
 *
 * @example
 * ```tsx
 * const { data, error, isLoading, mutate } = useBamlAction(StreamingActions.TestAws, { stream: true });
 * ```
 */
function useBamlAction<FunctionName extends FunctionNames>(
  action: ServerAction,
  props: HookInput<FunctionName, { stream: false }>,
): HookOutput<FunctionName, { stream: false }>;
function useBamlAction<FunctionName extends FunctionNames>(
  action: ServerAction,
  props?: HookInput<FunctionName, { stream?: true }>,
): HookOutput<FunctionName, { stream: true }>;
function useBamlAction<FunctionName extends FunctionNames>(
  action: ServerAction,
  props: HookInput<FunctionName, { stream?: boolean }> = {},
):
  | HookOutput<FunctionName, { stream: true }>
  | HookOutput<FunctionName, { stream: false }> {
  const { onFinalData, onError } = props;
  const [isLoading, startTransition] = useTransition();

  const [state, dispatch] = useReducer(
    hookReducer<StreamDataType<FunctionName>, FinalDataType<FunctionName>>,
    {
      isSuccess: false,
      error: undefined,
      finalData: undefined,
      isStreaming: false,
      streamData: undefined,
    },
  );

  const mutate = useCallback(
    async (...input: Parameters<ServerAction>) => {
      dispatch({ type: 'START_REQUEST' });
      try {
        let response: Awaited<ReturnType<ServerAction>>;
        startTransition(async () => {
          // Transform any BamlImage or BamlAudio inputs to their JSON representation
          const transformedInput = input.map((arg) => {
            // Check if the argument is an instance of BamlImage or BamlAudio
            // We check the constructor name since the actual classes might be proxied in browser environments
            if (
              arg &&
              typeof arg === 'object' &&
              (arg.constructor.name === 'BamlImage' ||
                arg.constructor.name === 'BamlAudio')
            ) {
              return arg.toJSON();
            }
            return arg;
          });

          response = await action(...transformedInput);

          if (isStreamingProps(props) && response instanceof ReadableStream) {
            const reader = response.getReader();
            const decoder = new TextDecoder();
            try {
              while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                if (value) {
                  const chunk = decoder.decode(value, { stream: true }).trim();
                  try {
                    const parsed: BamlStreamResponse<
                      StreamDataType<FunctionName>,
                      FinalDataType<FunctionName>
                    > = JSON.parse(chunk);
                    if (parsed.error) {
                      if (parsed.error instanceof Error) {
                        throw parsed.error;
                      }

                      const parsedError = JSON.parse(parsed.error);
                      const finalError = toBamlError(parsedError);
                      throw finalError;
                    }
                    if (parsed.partial !== undefined) {
                      dispatch({
                        type: 'SET_PARTIAL',
                        payload: parsed.partial,
                      });
                      if (isStreamingProps(props)) {
                        props.onStreamData?.(parsed.partial);
                      }
                      props.onData?.(parsed.partial);
                    }
                    if (parsed.final !== undefined) {
                      dispatch({ type: 'SET_FINAL', payload: parsed.final });
                      onFinalData?.(parsed.final);
                      props.onData?.(parsed.final);
                      return;
                    }
                  } catch (err: unknown) {
                    dispatch({
                      type: 'SET_ERROR',
                      payload: err as BamlErrors,
                    });
                    onError?.(err as BamlErrors);
                    break;
                  }
                }
              }
            } finally {
              reader.releaseLock();
            }
            return;
          }
          // Non‑streaming case
          dispatch({ type: 'SET_FINAL', payload: response });
          onFinalData?.(response);
        });
        return response;
      } catch (error_: unknown) {
        dispatch({ type: 'SET_ERROR', payload: error_ as BamlErrors });
        onError?.(error_ as BamlErrors);
        throw error_;
      }
    },
    [action, onFinalData, onError, props],
  );

  const status = useMemo<HookStatus<{ stream: typeof props.stream }>>(() => {
    if (state.error) return 'error';
    if (state.isSuccess) return 'success';
    if (state.isStreaming) return 'streaming';
    if (isLoading) return 'pending';
    return 'idle';
  }, [isLoading, state.error, state.isSuccess, state.isStreaming]);

  let data:
    | FinalDataType<FunctionName>
    | StreamDataType<FunctionName>
    | undefined = state.finalData;
  if (state.isStreaming) data = state.streamData;

  const result = {
    data,
    finalData: state.finalData,
    error: state.error,
    isError: status === 'error',
    isSuccess: status === 'success',
    isStreaming: status === 'streaming',
    isPending: status === 'pending',
    isLoading: status === 'pending' || status === 'streaming',
    mutate,
    status,
    reset: () => dispatch({ type: 'RESET' }),
  } satisfies HookOutput<FunctionName, { stream: typeof props.stream }>;

  return {
    ...result,
    streamData: isStreamingProps(props) ? state.streamData : undefined,
  } satisfies HookOutput<FunctionName, { stream: typeof props.stream }>;
}
/**
 * A specialized hook for the AnalyzeAccessibility BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** AccessibilityReport
 * - **Streaming Partial:** partial_types.AccessibilityReport
 * - **Streaming Final:** AccessibilityReport
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnalyzeAccessibility({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnalyzeAccessibility({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeAccessibility(
  props: HookInput<'AnalyzeAccessibility', { stream: false }>,
): HookOutput<'AnalyzeAccessibility', { stream: false }>;
export function useAnalyzeAccessibility(
  props?: HookInput<'AnalyzeAccessibility', { stream?: true }>,
): HookOutput<'AnalyzeAccessibility', { stream: true }>;
export function useAnalyzeAccessibility(
  props: HookInput<'AnalyzeAccessibility', { stream?: boolean }> = {},
):
  | HookOutput<'AnalyzeAccessibility', { stream: true }>
  | HookOutput<'AnalyzeAccessibility', { stream: false }> {
  let action: ServerAction = Actions.AnalyzeAccessibility;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnalyzeAccessibility;
  }
  return useBamlAction(action, props as HookInput);
}
/**
 * A specialized hook for the AnalyzeAltText BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** AltTextReport
 * - **Streaming Partial:** partial_types.AltTextReport
 * - **Streaming Final:** AltTextReport
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnalyzeAltText({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnalyzeAltText({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeAltText(
  props: HookInput<'AnalyzeAltText', { stream: false }>,
): HookOutput<'AnalyzeAltText', { stream: false }>;
export function useAnalyzeAltText(
  props?: HookInput<'AnalyzeAltText', { stream?: true }>,
): HookOutput<'AnalyzeAltText', { stream: true }>;
export function useAnalyzeAltText(
  props: HookInput<'AnalyzeAltText', { stream?: boolean }> = {},
):
  | HookOutput<'AnalyzeAltText', { stream: true }>
  | HookOutput<'AnalyzeAltText', { stream: false }> {
  let action: ServerAction = Actions.AnalyzeAltText;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnalyzeAltText;
  }
  return useBamlAction(action, props as HookInput);
}
/**
 * A specialized hook for the AnalyzeArticleSchemaMarkup BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** ArticleSchemaMarkupReport
 * - **Streaming Partial:** partial_types.ArticleSchemaMarkupReport
 * - **Streaming Final:** ArticleSchemaMarkupReport
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnalyzeArticleSchemaMarkup({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnalyzeArticleSchemaMarkup({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeArticleSchemaMarkup(
  props: HookInput<'AnalyzeArticleSchemaMarkup', { stream: false }>,
): HookOutput<'AnalyzeArticleSchemaMarkup', { stream: false }>;
export function useAnalyzeArticleSchemaMarkup(
  props?: HookInput<'AnalyzeArticleSchemaMarkup', { stream?: true }>,
): HookOutput<'AnalyzeArticleSchemaMarkup', { stream: true }>;
export function useAnalyzeArticleSchemaMarkup(
  props: HookInput<'AnalyzeArticleSchemaMarkup', { stream?: boolean }> = {},
):
  | HookOutput<'AnalyzeArticleSchemaMarkup', { stream: true }>
  | HookOutput<'AnalyzeArticleSchemaMarkup', { stream: false }> {
  let action: ServerAction = Actions.AnalyzeArticleSchemaMarkup;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnalyzeArticleSchemaMarkup;
  }
  return useBamlAction(action, props as HookInput);
}
/**
 * A specialized hook for the AnalyzeContentClarity BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** ContentClarityReport
 * - **Streaming Partial:** partial_types.ContentClarityReport
 * - **Streaming Final:** ContentClarityReport
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnalyzeContentClarity({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnalyzeContentClarity({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeContentClarity(
  props: HookInput<'AnalyzeContentClarity', { stream: false }>,
): HookOutput<'AnalyzeContentClarity', { stream: false }>;
export function useAnalyzeContentClarity(
  props?: HookInput<'AnalyzeContentClarity', { stream?: true }>,
): HookOutput<'AnalyzeContentClarity', { stream: true }>;
export function useAnalyzeContentClarity(
  props: HookInput<'AnalyzeContentClarity', { stream?: boolean }> = {},
):
  | HookOutput<'AnalyzeContentClarity', { stream: true }>
  | HookOutput<'AnalyzeContentClarity', { stream: false }> {
  let action: ServerAction = Actions.AnalyzeContentClarity;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnalyzeContentClarity;
  }
  return useBamlAction(action, props as HookInput);
}
/**
 * A specialized hook for the AnalyzeContentStructure BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** ContentStructure
 * - **Streaming Partial:** partial_types.ContentStructure
 * - **Streaming Final:** ContentStructure
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnalyzeContentStructure({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnalyzeContentStructure({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeContentStructure(
  props: HookInput<'AnalyzeContentStructure', { stream: false }>,
): HookOutput<'AnalyzeContentStructure', { stream: false }>;
export function useAnalyzeContentStructure(
  props?: HookInput<'AnalyzeContentStructure', { stream?: true }>,
): HookOutput<'AnalyzeContentStructure', { stream: true }>;
export function useAnalyzeContentStructure(
  props: HookInput<'AnalyzeContentStructure', { stream?: boolean }> = {},
):
  | HookOutput<'AnalyzeContentStructure', { stream: true }>
  | HookOutput<'AnalyzeContentStructure', { stream: false }> {
  let action: ServerAction = Actions.AnalyzeContentStructure;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnalyzeContentStructure;
  }
  return useBamlAction(action, props as HookInput);
}
/**
 * A specialized hook for the AnalyzeContrast BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** ContrastReport
 * - **Streaming Partial:** partial_types.ContrastReport
 * - **Streaming Final:** ContrastReport
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnalyzeContrast({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnalyzeContrast({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeContrast(
  props: HookInput<'AnalyzeContrast', { stream: false }>,
): HookOutput<'AnalyzeContrast', { stream: false }>;
export function useAnalyzeContrast(
  props?: HookInput<'AnalyzeContrast', { stream?: true }>,
): HookOutput<'AnalyzeContrast', { stream: true }>;
export function useAnalyzeContrast(
  props: HookInput<'AnalyzeContrast', { stream?: boolean }> = {},
):
  | HookOutput<'AnalyzeContrast', { stream: true }>
  | HookOutput<'AnalyzeContrast', { stream: false }> {
  let action: ServerAction = Actions.AnalyzeContrast;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnalyzeContrast;
  }
  return useBamlAction(action, props as HookInput);
}
/**
 * A specialized hook for the AnalyzeDescriptiveAltText BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** DescriptiveAltTextReport
 * - **Streaming Partial:** partial_types.DescriptiveAltTextReport
 * - **Streaming Final:** DescriptiveAltTextReport
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnalyzeDescriptiveAltText({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnalyzeDescriptiveAltText({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeDescriptiveAltText(
  props: HookInput<'AnalyzeDescriptiveAltText', { stream: false }>,
): HookOutput<'AnalyzeDescriptiveAltText', { stream: false }>;
export function useAnalyzeDescriptiveAltText(
  props?: HookInput<'AnalyzeDescriptiveAltText', { stream?: true }>,
): HookOutput<'AnalyzeDescriptiveAltText', { stream: true }>;
export function useAnalyzeDescriptiveAltText(
  props: HookInput<'AnalyzeDescriptiveAltText', { stream?: boolean }> = {},
):
  | HookOutput<'AnalyzeDescriptiveAltText', { stream: true }>
  | HookOutput<'AnalyzeDescriptiveAltText', { stream: false }> {
  let action: ServerAction = Actions.AnalyzeDescriptiveAltText;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnalyzeDescriptiveAltText;
  }
  return useBamlAction(action, props as HookInput);
}
/**
 * A specialized hook for the AnalyzeEEAT BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** EEATReport
 * - **Streaming Partial:** partial_types.EEATReport
 * - **Streaming Final:** EEATReport
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnalyzeEEAT({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnalyzeEEAT({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeEEAT(
  props: HookInput<'AnalyzeEEAT', { stream: false }>,
): HookOutput<'AnalyzeEEAT', { stream: false }>;
export function useAnalyzeEEAT(
  props?: HookInput<'AnalyzeEEAT', { stream?: true }>,
): HookOutput<'AnalyzeEEAT', { stream: true }>;
export function useAnalyzeEEAT(
  props: HookInput<'AnalyzeEEAT', { stream?: boolean }> = {},
):
  | HookOutput<'AnalyzeEEAT', { stream: true }>
  | HookOutput<'AnalyzeEEAT', { stream: false }> {
  let action: ServerAction = Actions.AnalyzeEEAT;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnalyzeEEAT;
  }
  return useBamlAction(action, props as HookInput);
}
/**
 * A specialized hook for the AnalyzeFAQSchemaMarkup BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** FAQSchemaMarkupReport
 * - **Streaming Partial:** partial_types.FAQSchemaMarkupReport
 * - **Streaming Final:** FAQSchemaMarkupReport
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnalyzeFAQSchemaMarkup({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnalyzeFAQSchemaMarkup({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeFAQSchemaMarkup(
  props: HookInput<'AnalyzeFAQSchemaMarkup', { stream: false }>,
): HookOutput<'AnalyzeFAQSchemaMarkup', { stream: false }>;
export function useAnalyzeFAQSchemaMarkup(
  props?: HookInput<'AnalyzeFAQSchemaMarkup', { stream?: true }>,
): HookOutput<'AnalyzeFAQSchemaMarkup', { stream: true }>;
export function useAnalyzeFAQSchemaMarkup(
  props: HookInput<'AnalyzeFAQSchemaMarkup', { stream?: boolean }> = {},
):
  | HookOutput<'AnalyzeFAQSchemaMarkup', { stream: true }>
  | HookOutput<'AnalyzeFAQSchemaMarkup', { stream: false }> {
  let action: ServerAction = Actions.AnalyzeFAQSchemaMarkup;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnalyzeFAQSchemaMarkup;
  }
  return useBamlAction(action, props as HookInput);
}
/**
 * A specialized hook for the AnalyzeFormAccessibility BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** FormAccessibilityReport
 * - **Streaming Partial:** partial_types.FormAccessibilityReport
 * - **Streaming Final:** FormAccessibilityReport
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnalyzeFormAccessibility({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnalyzeFormAccessibility({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeFormAccessibility(
  props: HookInput<'AnalyzeFormAccessibility', { stream: false }>,
): HookOutput<'AnalyzeFormAccessibility', { stream: false }>;
export function useAnalyzeFormAccessibility(
  props?: HookInput<'AnalyzeFormAccessibility', { stream?: true }>,
): HookOutput<'AnalyzeFormAccessibility', { stream: true }>;
export function useAnalyzeFormAccessibility(
  props: HookInput<'AnalyzeFormAccessibility', { stream?: boolean }> = {},
):
  | HookOutput<'AnalyzeFormAccessibility', { stream: true }>
  | HookOutput<'AnalyzeFormAccessibility', { stream: false }> {
  let action: ServerAction = Actions.AnalyzeFormAccessibility;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnalyzeFormAccessibility;
  }
  return useBamlAction(action, props as HookInput);
}
/**
 * A specialized hook for the AnalyzeH1Tag BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** H1TagReport
 * - **Streaming Partial:** partial_types.H1TagReport
 * - **Streaming Final:** H1TagReport
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnalyzeH1Tag({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnalyzeH1Tag({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeH1Tag(
  props: HookInput<'AnalyzeH1Tag', { stream: false }>,
): HookOutput<'AnalyzeH1Tag', { stream: false }>;
export function useAnalyzeH1Tag(
  props?: HookInput<'AnalyzeH1Tag', { stream?: true }>,
): HookOutput<'AnalyzeH1Tag', { stream: true }>;
export function useAnalyzeH1Tag(
  props: HookInput<'AnalyzeH1Tag', { stream?: boolean }> = {},
):
  | HookOutput<'AnalyzeH1Tag', { stream: true }>
  | HookOutput<'AnalyzeH1Tag', { stream: false }> {
  let action: ServerAction = Actions.AnalyzeH1Tag;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnalyzeH1Tag;
  }
  return useBamlAction(action, props as HookInput);
}
/**
 * A specialized hook for the AnalyzeHeadingHierarchy BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** HeadingHierarchyReport
 * - **Streaming Partial:** partial_types.HeadingHierarchyReport
 * - **Streaming Final:** HeadingHierarchyReport
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnalyzeHeadingHierarchy({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnalyzeHeadingHierarchy({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeHeadingHierarchy(
  props: HookInput<'AnalyzeHeadingHierarchy', { stream: false }>,
): HookOutput<'AnalyzeHeadingHierarchy', { stream: false }>;
export function useAnalyzeHeadingHierarchy(
  props?: HookInput<'AnalyzeHeadingHierarchy', { stream?: true }>,
): HookOutput<'AnalyzeHeadingHierarchy', { stream: true }>;
export function useAnalyzeHeadingHierarchy(
  props: HookInput<'AnalyzeHeadingHierarchy', { stream?: boolean }> = {},
):
  | HookOutput<'AnalyzeHeadingHierarchy', { stream: true }>
  | HookOutput<'AnalyzeHeadingHierarchy', { stream: false }> {
  let action: ServerAction = Actions.AnalyzeHeadingHierarchy;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnalyzeHeadingHierarchy;
  }
  return useBamlAction(action, props as HookInput);
}
/**
 * A specialized hook for the AnalyzeHeadingStructure BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** HeadingStructureReport
 * - **Streaming Partial:** partial_types.HeadingStructureReport
 * - **Streaming Final:** HeadingStructureReport
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnalyzeHeadingStructure({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnalyzeHeadingStructure({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeHeadingStructure(
  props: HookInput<'AnalyzeHeadingStructure', { stream: false }>,
): HookOutput<'AnalyzeHeadingStructure', { stream: false }>;
export function useAnalyzeHeadingStructure(
  props?: HookInput<'AnalyzeHeadingStructure', { stream?: true }>,
): HookOutput<'AnalyzeHeadingStructure', { stream: true }>;
export function useAnalyzeHeadingStructure(
  props: HookInput<'AnalyzeHeadingStructure', { stream?: boolean }> = {},
):
  | HookOutput<'AnalyzeHeadingStructure', { stream: true }>
  | HookOutput<'AnalyzeHeadingStructure', { stream: false }> {
  let action: ServerAction = Actions.AnalyzeHeadingStructure;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnalyzeHeadingStructure;
  }
  return useBamlAction(action, props as HookInput);
}
/**
 * A specialized hook for the AnalyzeKeyboardAccessibility BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** KeyboardAccessibilityReport
 * - **Streaming Partial:** partial_types.KeyboardAccessibilityReport
 * - **Streaming Final:** KeyboardAccessibilityReport
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnalyzeKeyboardAccessibility({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnalyzeKeyboardAccessibility({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeKeyboardAccessibility(
  props: HookInput<'AnalyzeKeyboardAccessibility', { stream: false }>,
): HookOutput<'AnalyzeKeyboardAccessibility', { stream: false }>;
export function useAnalyzeKeyboardAccessibility(
  props?: HookInput<'AnalyzeKeyboardAccessibility', { stream?: true }>,
): HookOutput<'AnalyzeKeyboardAccessibility', { stream: true }>;
export function useAnalyzeKeyboardAccessibility(
  props: HookInput<'AnalyzeKeyboardAccessibility', { stream?: boolean }> = {},
):
  | HookOutput<'AnalyzeKeyboardAccessibility', { stream: true }>
  | HookOutput<'AnalyzeKeyboardAccessibility', { stream: false }> {
  let action: ServerAction = Actions.AnalyzeKeyboardAccessibility;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnalyzeKeyboardAccessibility;
  }
  return useBamlAction(action, props as HookInput);
}
/**
 * A specialized hook for the AnalyzeMainSections BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** MainSectionsReport
 * - **Streaming Partial:** partial_types.MainSectionsReport
 * - **Streaming Final:** MainSectionsReport
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnalyzeMainSections({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnalyzeMainSections({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeMainSections(
  props: HookInput<'AnalyzeMainSections', { stream: false }>,
): HookOutput<'AnalyzeMainSections', { stream: false }>;
export function useAnalyzeMainSections(
  props?: HookInput<'AnalyzeMainSections', { stream?: true }>,
): HookOutput<'AnalyzeMainSections', { stream: true }>;
export function useAnalyzeMainSections(
  props: HookInput<'AnalyzeMainSections', { stream?: boolean }> = {},
):
  | HookOutput<'AnalyzeMainSections', { stream: true }>
  | HookOutput<'AnalyzeMainSections', { stream: false }> {
  let action: ServerAction = Actions.AnalyzeMainSections;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnalyzeMainSections;
  }
  return useBamlAction(action, props as HookInput);
}
/**
 * A specialized hook for the AnalyzeSemanticElements BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** SemanticElementsReport
 * - **Streaming Partial:** partial_types.SemanticElementsReport
 * - **Streaming Final:** SemanticElementsReport
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnalyzeSemanticElements({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnalyzeSemanticElements({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeSemanticElements(
  props: HookInput<'AnalyzeSemanticElements', { stream: false }>,
): HookOutput<'AnalyzeSemanticElements', { stream: false }>;
export function useAnalyzeSemanticElements(
  props?: HookInput<'AnalyzeSemanticElements', { stream?: true }>,
): HookOutput<'AnalyzeSemanticElements', { stream: true }>;
export function useAnalyzeSemanticElements(
  props: HookInput<'AnalyzeSemanticElements', { stream?: boolean }> = {},
):
  | HookOutput<'AnalyzeSemanticElements', { stream: true }>
  | HookOutput<'AnalyzeSemanticElements', { stream: false }> {
  let action: ServerAction = Actions.AnalyzeSemanticElements;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnalyzeSemanticElements;
  }
  return useBamlAction(action, props as HookInput);
}
/**
 * A specialized hook for the AnalyzeSemanticTags BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** SemanticTagReport
 * - **Streaming Partial:** partial_types.SemanticTagReport
 * - **Streaming Final:** SemanticTagReport
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnalyzeSemanticTags({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnalyzeSemanticTags({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeSemanticTags(
  props: HookInput<'AnalyzeSemanticTags', { stream: false }>,
): HookOutput<'AnalyzeSemanticTags', { stream: false }>;
export function useAnalyzeSemanticTags(
  props?: HookInput<'AnalyzeSemanticTags', { stream?: true }>,
): HookOutput<'AnalyzeSemanticTags', { stream: true }>;
export function useAnalyzeSemanticTags(
  props: HookInput<'AnalyzeSemanticTags', { stream?: boolean }> = {},
):
  | HookOutput<'AnalyzeSemanticTags', { stream: true }>
  | HookOutput<'AnalyzeSemanticTags', { stream: false }> {
  let action: ServerAction = Actions.AnalyzeSemanticTags;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnalyzeSemanticTags;
  }
  return useBamlAction(action, props as HookInput);
}
/**
 * A specialized hook for the AnalyzeUserIntent BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** UserIntentReport
 * - **Streaming Partial:** partial_types.UserIntentReport
 * - **Streaming Final:** UserIntentReport
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnalyzeUserIntent({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnalyzeUserIntent({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeUserIntent(
  props: HookInput<'AnalyzeUserIntent', { stream: false }>,
): HookOutput<'AnalyzeUserIntent', { stream: false }>;
export function useAnalyzeUserIntent(
  props?: HookInput<'AnalyzeUserIntent', { stream?: true }>,
): HookOutput<'AnalyzeUserIntent', { stream: true }>;
export function useAnalyzeUserIntent(
  props: HookInput<'AnalyzeUserIntent', { stream?: boolean }> = {},
):
  | HookOutput<'AnalyzeUserIntent', { stream: true }>
  | HookOutput<'AnalyzeUserIntent', { stream: false }> {
  let action: ServerAction = Actions.AnalyzeUserIntent;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnalyzeUserIntent;
  }
  return useBamlAction(action, props as HookInput);
}
/**
 * A specialized hook for the AnalyzeWebsiteScreenshot BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** WebsiteScreenshotAnalysis
 * - **Streaming Partial:** partial_types.WebsiteScreenshotAnalysis
 * - **Streaming Final:** WebsiteScreenshotAnalysis
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnalyzeWebsiteScreenshot({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnalyzeWebsiteScreenshot({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeWebsiteScreenshot(
  props: HookInput<'AnalyzeWebsiteScreenshot', { stream: false }>,
): HookOutput<'AnalyzeWebsiteScreenshot', { stream: false }>;
export function useAnalyzeWebsiteScreenshot(
  props?: HookInput<'AnalyzeWebsiteScreenshot', { stream?: true }>,
): HookOutput<'AnalyzeWebsiteScreenshot', { stream: true }>;
export function useAnalyzeWebsiteScreenshot(
  props: HookInput<'AnalyzeWebsiteScreenshot', { stream?: boolean }> = {},
):
  | HookOutput<'AnalyzeWebsiteScreenshot', { stream: true }>
  | HookOutput<'AnalyzeWebsiteScreenshot', { stream: false }> {
  let action: ServerAction = Actions.AnalyzeWebsiteScreenshot;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnalyzeWebsiteScreenshot;
  }
  return useBamlAction(action, props as HookInput);
}
/**
 * A specialized hook for the AssessWebpageImages BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** WebpageImagesReport
 * - **Streaming Partial:** partial_types.WebpageImagesReport
 * - **Streaming Final:** WebpageImagesReport
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAssessWebpageImages({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAssessWebpageImages({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAssessWebpageImages(
  props: HookInput<'AssessWebpageImages', { stream: false }>,
): HookOutput<'AssessWebpageImages', { stream: false }>;
export function useAssessWebpageImages(
  props?: HookInput<'AssessWebpageImages', { stream?: true }>,
): HookOutput<'AssessWebpageImages', { stream: true }>;
export function useAssessWebpageImages(
  props: HookInput<'AssessWebpageImages', { stream?: boolean }> = {},
):
  | HookOutput<'AssessWebpageImages', { stream: true }>
  | HookOutput<'AssessWebpageImages', { stream: false }> {
  let action: ServerAction = Actions.AssessWebpageImages;
  if (isStreamingProps(props)) {
    action = StreamingActions.AssessWebpageImages;
  }
  return useBamlAction(action, props as HookInput);
}
/**
 * A specialized hook for the ExtractSEOMetadata BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** SEOMetadata
 * - **Streaming Partial:** partial_types.SEOMetadata
 * - **Streaming Final:** SEOMetadata
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useExtractSEOMetadata({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useExtractSEOMetadata({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExtractSEOMetadata(
  props: HookInput<'ExtractSEOMetadata', { stream: false }>,
): HookOutput<'ExtractSEOMetadata', { stream: false }>;
export function useExtractSEOMetadata(
  props?: HookInput<'ExtractSEOMetadata', { stream?: true }>,
): HookOutput<'ExtractSEOMetadata', { stream: true }>;
export function useExtractSEOMetadata(
  props: HookInput<'ExtractSEOMetadata', { stream?: boolean }> = {},
):
  | HookOutput<'ExtractSEOMetadata', { stream: true }>
  | HookOutput<'ExtractSEOMetadata', { stream: false }> {
  let action: ServerAction = Actions.ExtractSEOMetadata;
  if (isStreamingProps(props)) {
    action = StreamingActions.ExtractSEOMetadata;
  }
  return useBamlAction(action, props as HookInput);
}
/**
 * A specialized hook for the SuggestImprovements BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - seo: SEOMetadata
 *
 * - accessibility: AccessibilityReport
 *
 * - structure: ContentStructure
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** ImprovementSuggestions
 * - **Streaming Partial:** partial_types.ImprovementSuggestions
 * - **Streaming Final:** ImprovementSuggestions
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useSuggestImprovements({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useSuggestImprovements({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useSuggestImprovements(
  props: HookInput<'SuggestImprovements', { stream: false }>,
): HookOutput<'SuggestImprovements', { stream: false }>;
export function useSuggestImprovements(
  props?: HookInput<'SuggestImprovements', { stream?: true }>,
): HookOutput<'SuggestImprovements', { stream: true }>;
export function useSuggestImprovements(
  props: HookInput<'SuggestImprovements', { stream?: boolean }> = {},
):
  | HookOutput<'SuggestImprovements', { stream: true }>
  | HookOutput<'SuggestImprovements', { stream: false }> {
  let action: ServerAction = Actions.SuggestImprovements;
  if (isStreamingProps(props)) {
    action = StreamingActions.SuggestImprovements;
  }
  return useBamlAction(action, props as HookInput);
}
