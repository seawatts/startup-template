/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: do not edit it. Instead, edit the BAML
// files and re-generate this code.
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code
import type { BamlCtxManager, BamlRuntime, ClientRegistry, Collector, Image } from "@boundaryml/baml"
import { toBamlError } from '@boundaryml/baml';
import {
  DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_CTX,
  DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME,
} from './globals';
import { LlmResponseParser, LlmStreamParser } from './parser';
import { HttpRequest, HttpStreamRequest } from './sync_request';
import type TypeBuilder from './type_builder';
import type { RecursivePartialNull as MovedRecursivePartialNull } from './types';
import type {
  AccessibilityReport,
  AltTextReport,
  ArticleSchemaMarkupReport,
  ContentClarityReport,
  ContentStructure,
  ContrastReport,
  DescriptiveAltTextReport,
  EEATReport,
  FAQSchemaMarkupReport,
  FormAccessibilityReport,
  H1TagReport,
  HeadingHierarchyReport,
  HeadingStructureReport,
  ImprovementSuggestions,
  KeyboardAccessibilityReport,
  MainSectionsReport,
  SEOMetadata,
  SemanticElementsReport,
  SemanticTagReport,
  UserIntentReport,
  WebpageImagesReport,
  WebsiteScreenshotAnalysis,
} from './types';

/**
 * @deprecated Use RecursivePartialNull from 'baml_client/types' instead.
 * Example:
 * ```ts
 * import { RecursivePartialNull } from './baml_client/types'
 * ```
 */
export type RecursivePartialNull<T> = MovedRecursivePartialNull<T>;

type BamlCallOptions = {
  tb?: TypeBuilder;
  clientRegistry?: ClientRegistry;
  collector?: Collector | Collector[];
};

export class BamlSyncClient {
  private httpRequest: HttpRequest;
  private httpStreamRequest: HttpStreamRequest;
  private llmResponseParser: LlmResponseParser;
  private llmStreamParser: LlmStreamParser;
  private bamlOptions: BamlCallOptions;

  constructor(
    private runtime: BamlRuntime,
    private ctxManager: BamlCtxManager,
    private bamlOptions?: BamlCallOptions,
  ) {
    this.httpRequest = new HttpRequest(runtime, ctxManager);
    this.httpStreamRequest = new HttpStreamRequest(runtime, ctxManager);
    this.llmResponseParser = new LlmResponseParser(runtime, ctxManager);
    this.llmStreamParser = new LlmStreamParser(runtime, ctxManager);
    this.bamlOptions = bamlOptions || {};
  }

  withOptions(bamlOptions: BamlCallOptions) {
    return new BamlSyncClient(this.runtime, this.ctxManager, bamlOptions);
  }

  /*
   * @deprecated NOT IMPLEMENTED as streaming must by async. We
   * are not providing an async version as we want to reserve the
   * right to provide a sync version in the future.
   */
  get stream() {
    throw new Error(
      "stream is not available in BamlSyncClient. Use `import { b } from 'baml_client/async_client",
    );
  }

  get request() {
    return this.httpRequest;
  }

  get streamRequest() {
    return this.httpStreamRequest;
  }

  get parse() {
    return this.llmResponseParser;
  }

  get parseStream() {
    return this.llmStreamParser;
  }

  AnalyzeAccessibility(
    img: Image,
    __baml_options__?: BamlCallOptions,
  ): AccessibilityReport {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'AnalyzeAccessibility',
        {
          img: img,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as AccessibilityReport;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }

  AnalyzeAltText(
    img: Image,
    __baml_options__?: BamlCallOptions,
  ): AltTextReport {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'AnalyzeAltText',
        {
          img: img,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as AltTextReport;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }

  AnalyzeArticleSchemaMarkup(
    img: Image,
    __baml_options__?: BamlCallOptions,
  ): ArticleSchemaMarkupReport {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'AnalyzeArticleSchemaMarkup',
        {
          img: img,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as ArticleSchemaMarkupReport;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }

  AnalyzeContentClarity(
    img: Image,
    __baml_options__?: BamlCallOptions,
  ): ContentClarityReport {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'AnalyzeContentClarity',
        {
          img: img,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as ContentClarityReport;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }

  AnalyzeContentStructure(
    img: Image,
    __baml_options__?: BamlCallOptions,
  ): ContentStructure {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'AnalyzeContentStructure',
        {
          img: img,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as ContentStructure;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }

  AnalyzeContrast(
    img: Image,
    __baml_options__?: BamlCallOptions,
  ): ContrastReport {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'AnalyzeContrast',
        {
          img: img,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as ContrastReport;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }

  AnalyzeDescriptiveAltText(
    img: Image,
    __baml_options__?: BamlCallOptions,
  ): DescriptiveAltTextReport {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'AnalyzeDescriptiveAltText',
        {
          img: img,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as DescriptiveAltTextReport;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }

  AnalyzeEEAT(img: Image, __baml_options__?: BamlCallOptions): EEATReport {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'AnalyzeEEAT',
        {
          img: img,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as EEATReport;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }

  AnalyzeFAQSchemaMarkup(
    img: Image,
    __baml_options__?: BamlCallOptions,
  ): FAQSchemaMarkupReport {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'AnalyzeFAQSchemaMarkup',
        {
          img: img,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as FAQSchemaMarkupReport;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }

  AnalyzeFormAccessibility(
    img: Image,
    __baml_options__?: BamlCallOptions,
  ): FormAccessibilityReport {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'AnalyzeFormAccessibility',
        {
          img: img,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as FormAccessibilityReport;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }

  AnalyzeH1Tag(img: Image, __baml_options__?: BamlCallOptions): H1TagReport {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'AnalyzeH1Tag',
        {
          img: img,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as H1TagReport;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }

  AnalyzeHeadingHierarchy(
    img: Image,
    __baml_options__?: BamlCallOptions,
  ): HeadingHierarchyReport {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'AnalyzeHeadingHierarchy',
        {
          img: img,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as HeadingHierarchyReport;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }

  AnalyzeHeadingStructure(
    img: Image,
    __baml_options__?: BamlCallOptions,
  ): HeadingStructureReport {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'AnalyzeHeadingStructure',
        {
          img: img,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as HeadingStructureReport;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }

  AnalyzeKeyboardAccessibility(
    img: Image,
    __baml_options__?: BamlCallOptions,
  ): KeyboardAccessibilityReport {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'AnalyzeKeyboardAccessibility',
        {
          img: img,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as KeyboardAccessibilityReport;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }

  AnalyzeMainSections(
    img: Image,
    __baml_options__?: BamlCallOptions,
  ): MainSectionsReport {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'AnalyzeMainSections',
        {
          img: img,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as MainSectionsReport;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }

  AnalyzeSemanticElements(
    img: Image,
    __baml_options__?: BamlCallOptions,
  ): SemanticElementsReport {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'AnalyzeSemanticElements',
        {
          img: img,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as SemanticElementsReport;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }

  AnalyzeSemanticTags(
    img: Image,
    __baml_options__?: BamlCallOptions,
  ): SemanticTagReport {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'AnalyzeSemanticTags',
        {
          img: img,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as SemanticTagReport;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }

  AnalyzeUserIntent(
    img: Image,
    __baml_options__?: BamlCallOptions,
  ): UserIntentReport {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'AnalyzeUserIntent',
        {
          img: img,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as UserIntentReport;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }

  AnalyzeWebsiteScreenshot(
    img: Image,
    __baml_options__?: BamlCallOptions,
  ): WebsiteScreenshotAnalysis {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'AnalyzeWebsiteScreenshot',
        {
          img: img,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as WebsiteScreenshotAnalysis;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }

  AssessWebpageImages(
    img: Image,
    __baml_options__?: BamlCallOptions,
  ): WebpageImagesReport {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'AssessWebpageImages',
        {
          img: img,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as WebpageImagesReport;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }

  ExtractSEOMetadata(
    img: Image,
    __baml_options__?: BamlCallOptions,
  ): SEOMetadata {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'ExtractSEOMetadata',
        {
          img: img,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as SEOMetadata;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }

  SuggestImprovements(
    seo: SEOMetadata,
    accessibility: AccessibilityReport,
    structure: ContentStructure,
    __baml_options__?: BamlCallOptions,
  ): ImprovementSuggestions {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
      const collector = options.collector
        ? Array.isArray(options.collector)
          ? options.collector
          : [options.collector]
        : [];
      const raw = this.runtime.callFunctionSync(
        'SuggestImprovements',
        {
          seo: seo,
          accessibility: accessibility,
          structure: structure,
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
      );
      return raw.parsed(false) as ImprovementSuggestions;
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
}

export const b = new BamlSyncClient(
  DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME,
  DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_CTX,
);
